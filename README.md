# WRO-Future-Engineers-PH
The team quickly conceptualized the materials after learning the theme for this year's World Robotics Olympiad for Future Engineers which is self-driving cars. According to the guidelines, there is no brand requirement or restriction for the robot. With that knowledge, the team decided that their robot's primary purpose should be to move efficiently over the track by using a solid base and a well-thought-out program. In order to maximize each turn and obstacle, the DYCI Primes 3.0 made sure to design a program that identifies the distance between the three sides of the robot. 

Given its accessibility and effectiveness in the building and programming aspects, the team decided to use Lego Technic components. Lego is undoubtedly one of those building materials that allow for creativity while creating, and it also adds that once the base or structure is built, it is stable. This feature of the building material we've chosen allows us to construct a robot car that is stable enough to turn precisely and move along the track. 

The team considers that the so-called "golden ratio" of 1.6 to 1.7 would be ideal for the mission, thus this is another concept we want to incorporate into our robot. Of course, the vehicles used in drag racing are at the other extreme of the scale, with a distorted ratio considerably greater than that, while a vehicle like a go-kart is at the other extreme, with a ratio of roughly 1:1. If everything else were equal, the trade-off would be between stability (longer wheelbase) and agility (shorter wheelbase). Evidently, a lower ratio would handle a lot of lower-speed cornering and turn-in better than a higher ratio (wheelbase: track width) in high-speed turning. 

As for the design of the robot, we collectively decided to place the majority of the weight at the back of the car for it to be able to properly rotate, this is also the reason why the wheels at the front are thinner than at the back; it is to provide enough friction when it starts and stops, allowing for much easier and more precise steering. As for the steering mechanism, we decided to use a medium motor connected to a 24t gear that is then connected to a 40t gear to take control of our car. 

The robot turns on its motors and starts counting, with the left and right sensors also storing the values they are reading into the variables leftsidepos and rightsidepos respectively; when the sum of the left and right sensors exceeds or equaled 150 cm, the robot stops counting and stores the counted seconds to a variable ypo, the robot will now then determine which ultrasonic sensor gave the greater value and turn towards the direction of the corresponding ultrasonic sensor's side that gave the greater value. However, if the front ultrasonic sensor then detects something in its path within 10 cm and the sum of the left and right sensors doesn't exceed 150 cm, it means the robot has detected an obstacle; the robot will then determine whether the left or right ultrasonic sensor possesses the greater value and turn accordingly to avoid the incoming obstacle. 

The members of our team have found several cases where the robot would go out of line; there are many reasons for this, such as the smoothness of the track, the dirt clinging into the robot's wheel's, and other forces outside of our understanding; to combat this, we had made an algorithm to self-center the robot; we had done it in two ways, first, by using the the left and right sensors, if the sum of both sensors doesn't exceed or equal to 150 cm, it then checks if the left or right sensor doesn't exceed a two certain thresholds, firstly, the value of either sensor must not exceed 15 cm, if it does exceed that value, the robot then responds by turning right, if the right sensor is the one to exceed the value, and left, if the left sensor is the one to exceed that value; on the not so rare occasion that the robot sticks to closely to the wall, with either sensors reading values below 5, endangering itself, our points, and ourselves, the robot then responds by turning right, if the left sensor reads below 5 cm, and left, if the right sensor reads below 5; as for the second method, which is using the gyro sensor, the robot simply turns itself when the gyro reads above or below 0, if the value had gone negative, the robot will turn left, if it goes positive, it turns right; the duration and angle depends entirely on the value of the gyro sensor, making sure the robot turns as precisely as possible. When the robot finally turns 90 degrees, it adds a value of 1 to a variable named 'rotation'; once it hits 4, the robot will start counting again, stopping when ‘rotation’ hits 5 and storing the value to a variable named ypn; once the value had reached 12, the robot has now turned three times, it will then subtract ypn to ypo, to determine the y axis as to where the robot would stop, the next step would be then using the value of the leftsidepos and the rightsidepos to make the robot turn to exact x-axis; after all of this is done, the robot then ends the program.
